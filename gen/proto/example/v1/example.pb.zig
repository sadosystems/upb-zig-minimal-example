//! Generated by protoc-gen-zig from proto/example/v1/example.proto
//! DO NOT EDIT - changes will be overwritten
//!
//! This file provides typed Zig bindings over upb for the protobuf
//! definitions in proto/example/v1/example.proto.

const std = @import("std");
const upb_zig = @import("upb_zig");
const google_protobuf_timestamp = @import("google_protobuf_timestamp");

// Embedded serialized FileDescriptorProto for this file.
// Used to initialize MiniTables at runtime via upb reflection.
const _file_descriptor_bytes = "\x0a\x1e\x70\x72\x6f\x74\x6f\x2f\x65\x78\x61\x6d\x70\x6c\x65\x2f\x76\x31\x2f\x65\x78\x61\x6d\x70\x6c\x65\x2e\x70\x72\x6f\x74\x6f\x12\x0a\x65\x78\x61\x6d\x70\x6c\x65\x2e\x76\x31\x1a\x1f\x67\x6f\x6f\x67\x6c\x65\x2f\x70\x72\x6f\x74\x6f\x62\x75\x66\x2f\x74\x69\x6d\x65\x73\x74\x61\x6d\x70\x2e\x70\x72\x6f\x74\x6f\x22\x8b\x02\x0a\x06\x50\x65\x72\x73\x6f\x6e\x12\x12\x0a\x04\x6e\x61\x6d\x65\x18\x01\x20\x01\x28\x09\x52\x04\x6e\x61\x6d\x65\x12\x0e\x0a\x02\x69\x64\x18\x02\x20\x01\x28\x05\x52\x02\x69\x64\x12\x14\x0a\x05\x65\x6d\x61\x69\x6c\x18\x03\x20\x01\x28\x09\x52\x05\x65\x6d\x61\x69\x6c\x12\x36\x0a\x06\x70\x68\x6f\x6e\x65\x73\x18\x04\x20\x03\x28\x0b\x32\x1e\x2e\x65\x78\x61\x6d\x70\x6c\x65\x2e\x76\x31\x2e\x50\x65\x72\x73\x6f\x6e\x2e\x50\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x52\x06\x70\x68\x6f\x6e\x65\x73\x12\x3d\x0a\x0c\x6c\x61\x73\x74\x5f\x75\x70\x64\x61\x74\x65\x64\x18\x05\x20\x01\x28\x0b\x32\x1a\x2e\x67\x6f\x6f\x67\x6c\x65\x2e\x70\x72\x6f\x74\x6f\x62\x75\x66\x2e\x54\x69\x6d\x65\x73\x74\x61\x6d\x70\x52\x0b\x6c\x61\x73\x74\x55\x70\x64\x61\x74\x65\x64\x1a\x50\x0a\x0b\x50\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x12\x16\x0a\x06\x6e\x75\x6d\x62\x65\x72\x18\x01\x20\x01\x28\x09\x52\x06\x6e\x75\x6d\x62\x65\x72\x12\x29\x0a\x04\x74\x79\x70\x65\x18\x02\x20\x01\x28\x0e\x32\x15\x2e\x65\x78\x61\x6d\x70\x6c\x65\x2e\x76\x31\x2e\x50\x68\x6f\x6e\x65\x54\x79\x70\x65\x52\x04\x74\x79\x70\x65\x22\x39\x0a\x0b\x41\x64\x64\x72\x65\x73\x73\x42\x6f\x6f\x6b\x12\x2a\x0a\x06\x70\x65\x6f\x70\x6c\x65\x18\x01\x20\x03\x28\x0b\x32\x12\x2e\x65\x78\x61\x6d\x70\x6c\x65\x2e\x76\x31\x2e\x50\x65\x72\x73\x6f\x6e\x52\x06\x70\x65\x6f\x70\x6c\x65\x2a\x68\x0a\x09\x50\x68\x6f\x6e\x65\x54\x79\x70\x65\x12\x1a\x0a\x16\x50\x48\x4f\x4e\x45\x5f\x54\x59\x50\x45\x5f\x55\x4e\x53\x50\x45\x43\x49\x46\x49\x45\x44\x10\x00\x12\x15\x0a\x11\x50\x48\x4f\x4e\x45\x5f\x54\x59\x50\x45\x5f\x4d\x4f\x42\x49\x4c\x45\x10\x01\x12\x13\x0a\x0f\x50\x48\x4f\x4e\x45\x5f\x54\x59\x50\x45\x5f\x48\x4f\x4d\x45\x10\x02\x12\x13\x0a\x0f\x50\x48\x4f\x4e\x45\x5f\x54\x59\x50\x45\x5f\x57\x4f\x52\x4b\x10\x03\x4a\x93\x06\x0a\x06\x12\x04\x00\x00\x1d\x01\x0a\x08\x0a\x01\x0c\x12\x03\x00\x00\x12\x0a\x08\x0a\x01\x02\x12\x03\x02\x00\x13\x0a\x09\x0a\x02\x03\x00\x12\x03\x03\x00\x29\x0a\x0a\x0a\x02\x04\x00\x12\x04\x05\x00\x12\x01\x0a\x0a\x0a\x03\x04\x00\x01\x12\x03\x05\x08\x0e\x0a\x0b\x0a\x04\x04\x00\x02\x00\x12\x03\x06\x02\x12\x0a\x0c\x0a\x05\x04\x00\x02\x00\x05\x12\x03\x06\x02\x08\x0a\x0c\x0a\x05\x04\x00\x02\x00\x01\x12\x03\x06\x09\x0d\x0a\x0c\x0a\x05\x04\x00\x02\x00\x03\x12\x03\x06\x10\x11\x0a\x0b\x0a\x04\x04\x00\x02\x01\x12\x03\x07\x02\x0f\x0a\x0c\x0a\x05\x04\x00\x02\x01\x05\x12\x03\x07\x02\x07\x0a\x0c\x0a\x05\x04\x00\x02\x01\x01\x12\x03\x07\x08\x0a\x0a\x0c\x0a\x05\x04\x00\x02\x01\x03\x12\x03\x07\x0d\x0e\x0a\x0b\x0a\x04\x04\x00\x02\x02\x12\x03\x08\x02\x13\x0a\x0c\x0a\x05\x04\x00\x02\x02\x05\x12\x03\x08\x02\x08\x0a\x0c\x0a\x05\x04\x00\x02\x02\x01\x12\x03\x08\x09\x0e\x0a\x0c\x0a\x05\x04\x00\x02\x02\x03\x12\x03\x08\x11\x12\x0a\x0c\x0a\x04\x04\x00\x03\x00\x12\x04\x0a\x02\x0d\x03\x0a\x0c\x0a\x05\x04\x00\x03\x00\x01\x12\x03\x0a\x0a\x15\x0a\x0d\x0a\x06\x04\x00\x03\x00\x02\x00\x12\x03\x0b\x04\x16\x0a\x0e\x0a\x07\x04\x00\x03\x00\x02\x00\x05\x12\x03\x0b\x04\x0a\x0a\x0e\x0a\x07\x04\x00\x03\x00\x02\x00\x01\x12\x03\x0b\x0b\x11\x0a\x0e\x0a\x07\x04\x00\x03\x00\x02\x00\x03\x12\x03\x0b\x14\x15\x0a\x0d\x0a\x06\x04\x00\x03\x00\x02\x01\x12\x03\x0c\x04\x17\x0a\x0e\x0a\x07\x04\x00\x03\x00\x02\x01\x06\x12\x03\x0c\x04\x0d\x0a\x0e\x0a\x07\x04\x00\x03\x00\x02\x01\x01\x12\x03\x0c\x0e\x12\x0a\x0e\x0a\x07\x04\x00\x03\x00\x02\x01\x03\x12\x03\x0c\x15\x16\x0a\x0b\x0a\x04\x04\x00\x02\x03\x12\x03\x0f\x02\x22\x0a\x0c\x0a\x05\x04\x00\x02\x03\x04\x12\x03\x0f\x02\x0a\x0a\x0c\x0a\x05\x04\x00\x02\x03\x06\x12\x03\x0f\x0b\x16\x0a\x0c\x0a\x05\x04\x00\x02\x03\x01\x12\x03\x0f\x17\x1d\x0a\x0c\x0a\x05\x04\x00\x02\x03\x03\x12\x03\x0f\x20\x21\x0a\x0b\x0a\x04\x04\x00\x02\x04\x12\x03\x11\x02\x2d\x0a\x0c\x0a\x05\x04\x00\x02\x04\x06\x12\x03\x11\x02\x1b\x0a\x0c\x0a\x05\x04\x00\x02\x04\x01\x12\x03\x11\x1c\x28\x0a\x0c\x0a\x05\x04\x00\x02\x04\x03\x12\x03\x11\x2b\x2c\x0a\x0a\x0a\x02\x05\x00\x12\x04\x14\x00\x19\x01\x0a\x0a\x0a\x03\x05\x00\x01\x12\x03\x14\x05\x0e\x0a\x0b\x0a\x04\x05\x00\x02\x00\x12\x03\x15\x02\x1d\x0a\x0c\x0a\x05\x05\x00\x02\x00\x01\x12\x03\x15\x02\x18\x0a\x0c\x0a\x05\x05\x00\x02\x00\x02\x12\x03\x15\x1b\x1c\x0a\x0b\x0a\x04\x05\x00\x02\x01\x12\x03\x16\x02\x18\x0a\x0c\x0a\x05\x05\x00\x02\x01\x01\x12\x03\x16\x02\x13\x0a\x0c\x0a\x05\x05\x00\x02\x01\x02\x12\x03\x16\x16\x17\x0a\x0b\x0a\x04\x05\x00\x02\x02\x12\x03\x17\x02\x16\x0a\x0c\x0a\x05\x05\x00\x02\x02\x01\x12\x03\x17\x02\x11\x0a\x0c\x0a\x05\x05\x00\x02\x02\x02\x12\x03\x17\x14\x15\x0a\x0b\x0a\x04\x05\x00\x02\x03\x12\x03\x18\x02\x16\x0a\x0c\x0a\x05\x05\x00\x02\x03\x01\x12\x03\x18\x02\x11\x0a\x0c\x0a\x05\x05\x00\x02\x03\x02\x12\x03\x18\x14\x15\x0a\x0a\x0a\x02\x04\x01\x12\x04\x1b\x00\x1d\x01\x0a\x0a\x0a\x03\x04\x01\x01\x12\x03\x1b\x08\x13\x0a\x0b\x0a\x04\x04\x01\x02\x00\x12\x03\x1c\x02\x1d\x0a\x0c\x0a\x05\x04\x01\x02\x00\x04\x12\x03\x1c\x02\x0a\x0a\x0c\x0a\x05\x04\x01\x02\x00\x06\x12\x03\x1c\x0b\x11\x0a\x0c\x0a\x05\x04\x01\x02\x00\x01\x12\x03\x1c\x12\x18\x0a\x0c\x0a\x05\x04\x01\x02\x00\x03\x12\x03\x1c\x1b\x1c\x62\x06\x70\x72\x6f\x74\x6f\x33";

// Initialization state
var _init_done: bool = false;

/// Initialize all message MiniTables from the embedded descriptor.
/// Called automatically on first use of any message in this file.
/// This function is public so dependencies can call it.
pub fn _file_init() void {
    if (_init_done) return;
    _init_done = true;

    // Initialize dependencies first (they add their descriptors to the shared pool)
    google_protobuf_timestamp._file_init();

    // Get the shared DefPool and load this file's descriptor
    const pool = upb_zig.sharedDefPool() catch return;
    pool.addFile(_file_descriptor_bytes);

    // Initialize MiniTables for all messages
    if (pool.findMessage("example.v1.Person")) |msg_def| {
        Person.msgdef = msg_def;
        Person.minitable = upb_zig.getMessageMiniTable(msg_def);
    }
    if (pool.findMessage("example.v1.AddressBook")) |msg_def| {
        AddressBook.msgdef = msg_def;
        AddressBook.minitable = upb_zig.getMessageMiniTable(msg_def);
    }
}

/// PhoneType enum from proto/example/v1/example.proto
pub const PhoneType = enum(i32) {
    PHONE_TYPE_UNSPECIFIED = 0,
    PHONE_TYPE_MOBILE = 1,
    PHONE_TYPE_HOME = 2,
    PHONE_TYPE_WORK = 3,

    pub fn fromInt(value: i32) ?PhoneType {
        return std.meta.intToEnum(PhoneType, value) catch null;
    }

    pub fn toInt(self: PhoneType) i32 {
        return @intFromEnum(self);
    }
};

/// Person message from proto/example/v1/example.proto
pub const Person = struct {
    /// Pointer to the underlying upb message
    _msg: *upb_zig.upb_Message,
    /// Arena that owns this message
    _arena: upb_zig.Arena,

    /// MiniTable descriptor for this message type.
    /// Initialized from embedded FileDescriptor on first use.
    pub var minitable: ?*const upb_zig.upb_MiniTable = null;

    /// MessageDef for this message type (needed for JSON encode/decode).
    pub var msgdef: ?*const upb_zig.upb_MessageDef = null;

    /// Field numbers for this message
    pub const FieldNumber = struct {
        pub const name: u32 = 1;
        pub const id: u32 = 2;
        pub const email: u32 = 3;
        pub const phones: u32 = 4;
        pub const last_updated: u32 = 5;
    };

    /// Cached field descriptors - populated on first access
    var fields_initialized: bool = false;
    var fields: [5]?*const upb_zig.upb_MiniTableField = .{null} ** 5;

    /// Initialize the MiniTable for this message type.
    /// Called automatically when needed; safe to call multiple times.
    pub fn ensureInit() void {
        if (minitable != null) return;
        _file_init();
    }

    fn getField(field_number: u32) ?*const upb_zig.upb_MiniTableField {
        ensureInit();
        const mt = minitable orelse return null;
        return upb_zig.findFieldByNumber(mt, field_number);
    }

    // Nested enums

    // Nested messages (simplified - just type alias for now)
    pub const PhoneNumber = struct {
        _msg: *upb_zig.upb_Message,
        _arena: upb_zig.Arena,
        pub var minitable: ?*const upb_zig.upb_MiniTable = null;
    };

    // Oneofs

    /// name field (string, field number 1)
    pub fn getName(self: *const Person) []const u8 {
        const field_desc = getField(FieldNumber.name) orelse return "";
        return upb_zig.getString(self._msg, field_desc, "");
    }

    pub fn setName(self: *Person, value: []const u8) void {
        const field_desc = getField(FieldNumber.name) orelse return;
        upb_zig.setString(self._msg, field_desc, value);
    }

    /// id field (int32, field number 2)
    pub fn getId(self: *const Person) i32 {
        const field_desc = getField(FieldNumber.id) orelse return 0;
        return upb_zig.getInt32(self._msg, field_desc, 0);
    }

    pub fn setId(self: *Person, value: i32) void {
        const field_desc = getField(FieldNumber.id) orelse return;
        upb_zig.setInt32(self._msg, field_desc, value);
    }

    /// email field (string, field number 3)
    pub fn getEmail(self: *const Person) []const u8 {
        const field_desc = getField(FieldNumber.email) orelse return "";
        return upb_zig.getString(self._msg, field_desc, "");
    }

    pub fn setEmail(self: *Person, value: []const u8) void {
        const field_desc = getField(FieldNumber.email) orelse return;
        upb_zig.setString(self._msg, field_desc, value);
    }

    /// phones field (message, field number 4)
    pub fn phonesCount(self: *const Person) usize {
        const field_desc = getField(FieldNumber.phones) orelse return 0;
        return upb_zig.getArrayLen(self._msg, field_desc);
    }

    pub fn getPhones(self: *const Person, index: usize) ?PhoneNumber {
        const field_desc = getField(FieldNumber.phones) orelse return null;
        const sub_msg = upb_zig.arrayGetMessage(self._msg, field_desc, index) orelse return null;
        return PhoneNumber{ ._msg = sub_msg, ._arena = self._arena };
    }

    pub fn addPhones(self: *Person, value: PhoneNumber) !void {
        const field_desc = getField(FieldNumber.phones) orelse return error.OutOfMemory;
        try upb_zig.arrayAppendMessage(self._msg, field_desc, value._msg, self._arena);
    }

    /// last_updated field (message, field number 5)
    pub fn getLastUpdated(self: *const Person) ?google_protobuf_timestamp.Timestamp {
        const field_desc = getField(FieldNumber.last_updated) orelse return null;
        const sub_msg = upb_zig.getMessage(self._msg, field_desc) orelse return null;
        return google_protobuf_timestamp.Timestamp{ ._msg = sub_msg, ._arena = self._arena };
    }

    pub fn setLastUpdated(self: *Person, value: google_protobuf_timestamp.Timestamp) void {
        const field_desc = getField(FieldNumber.last_updated) orelse return;
        upb_zig.setMessage(self._msg, field_desc, value._msg);
    }

    /// Serialize this message to wire format bytes.
    pub fn encode(self: *const Person) upb_zig.EncodeError![]const u8 {
        ensureInit();
        const mt = minitable orelse return error.EncodeFailed;
        return upb_zig.encode(self._msg, mt, self._arena);
    }

    /// Parse wire format bytes into a new message.
    pub fn decode(arena: upb_zig.Arena, data: []const u8) upb_zig.DecodeError!Person {
        ensureInit();
        const mt = minitable orelse return error.DecodeFailed;
        const msg = upb_zig.messageNew(mt, arena) orelse return error.DecodeFailed;
        try upb_zig.decode(msg, mt, data, arena);
        return Person{
            ._msg = msg,
            ._arena = arena,
        };
    }

    /// Serialize this message to JSON format.
    pub fn encodeJson(self: *const Person, options: upb_zig.JsonEncodeOptions) upb_zig.JsonEncodeError![]const u8 {
        ensureInit();
        const md = msgdef orelse return error.JsonEncodeFailed;
        const pool = upb_zig.sharedDefPool() catch return error.JsonEncodeFailed;
        return upb_zig.jsonEncode(self._msg, md, pool, self._arena, options);
    }

    /// Parse JSON into a new message.
    pub fn decodeJson(arena: upb_zig.Arena, json_data: []const u8, options: upb_zig.JsonDecodeOptions) upb_zig.JsonDecodeError!Person {
        ensureInit();
        const mt = minitable orelse return error.JsonDecodeFailed;
        const md = msgdef orelse return error.JsonDecodeFailed;
        const pool = upb_zig.sharedDefPool() catch return error.JsonDecodeFailed;
        const msg = upb_zig.messageNew(mt, arena) orelse return error.JsonDecodeFailed;
        try upb_zig.jsonDecode(msg, md, json_data, pool, arena, options);
        return Person{
            ._msg = msg,
            ._arena = arena,
        };
    }

    /// Create a new empty message.
    pub fn init(arena: upb_zig.Arena) !Person {
        ensureInit();
        const mt = minitable orelse return error.OutOfMemory;
        const msg = upb_zig.messageNew(mt, arena) orelse return error.OutOfMemory;
        return Person{
            ._msg = msg,
            ._arena = arena,
        };
    }
};

/// AddressBook message from proto/example/v1/example.proto
pub const AddressBook = struct {
    /// Pointer to the underlying upb message
    _msg: *upb_zig.upb_Message,
    /// Arena that owns this message
    _arena: upb_zig.Arena,

    /// MiniTable descriptor for this message type.
    /// Initialized from embedded FileDescriptor on first use.
    pub var minitable: ?*const upb_zig.upb_MiniTable = null;

    /// MessageDef for this message type (needed for JSON encode/decode).
    pub var msgdef: ?*const upb_zig.upb_MessageDef = null;

    /// Field numbers for this message
    pub const FieldNumber = struct {
        pub const people: u32 = 1;
    };

    /// Cached field descriptors - populated on first access
    var fields_initialized: bool = false;
    var fields: [1]?*const upb_zig.upb_MiniTableField = .{null} ** 1;

    /// Initialize the MiniTable for this message type.
    /// Called automatically when needed; safe to call multiple times.
    pub fn ensureInit() void {
        if (minitable != null) return;
        _file_init();
    }

    fn getField(field_number: u32) ?*const upb_zig.upb_MiniTableField {
        ensureInit();
        const mt = minitable orelse return null;
        return upb_zig.findFieldByNumber(mt, field_number);
    }

    // Nested enums

    // Nested messages (simplified - just type alias for now)

    // Oneofs

    /// people field (message, field number 1)
    pub fn peopleCount(self: *const AddressBook) usize {
        const field_desc = getField(FieldNumber.people) orelse return 0;
        return upb_zig.getArrayLen(self._msg, field_desc);
    }

    pub fn getPeople(self: *const AddressBook, index: usize) ?Person {
        const field_desc = getField(FieldNumber.people) orelse return null;
        const sub_msg = upb_zig.arrayGetMessage(self._msg, field_desc, index) orelse return null;
        return Person{ ._msg = sub_msg, ._arena = self._arena };
    }

    pub fn addPeople(self: *AddressBook, value: Person) !void {
        const field_desc = getField(FieldNumber.people) orelse return error.OutOfMemory;
        try upb_zig.arrayAppendMessage(self._msg, field_desc, value._msg, self._arena);
    }

    /// Serialize this message to wire format bytes.
    pub fn encode(self: *const AddressBook) upb_zig.EncodeError![]const u8 {
        ensureInit();
        const mt = minitable orelse return error.EncodeFailed;
        return upb_zig.encode(self._msg, mt, self._arena);
    }

    /// Parse wire format bytes into a new message.
    pub fn decode(arena: upb_zig.Arena, data: []const u8) upb_zig.DecodeError!AddressBook {
        ensureInit();
        const mt = minitable orelse return error.DecodeFailed;
        const msg = upb_zig.messageNew(mt, arena) orelse return error.DecodeFailed;
        try upb_zig.decode(msg, mt, data, arena);
        return AddressBook{
            ._msg = msg,
            ._arena = arena,
        };
    }

    /// Serialize this message to JSON format.
    pub fn encodeJson(self: *const AddressBook, options: upb_zig.JsonEncodeOptions) upb_zig.JsonEncodeError![]const u8 {
        ensureInit();
        const md = msgdef orelse return error.JsonEncodeFailed;
        const pool = upb_zig.sharedDefPool() catch return error.JsonEncodeFailed;
        return upb_zig.jsonEncode(self._msg, md, pool, self._arena, options);
    }

    /// Parse JSON into a new message.
    pub fn decodeJson(arena: upb_zig.Arena, json_data: []const u8, options: upb_zig.JsonDecodeOptions) upb_zig.JsonDecodeError!AddressBook {
        ensureInit();
        const mt = minitable orelse return error.JsonDecodeFailed;
        const md = msgdef orelse return error.JsonDecodeFailed;
        const pool = upb_zig.sharedDefPool() catch return error.JsonDecodeFailed;
        const msg = upb_zig.messageNew(mt, arena) orelse return error.JsonDecodeFailed;
        try upb_zig.jsonDecode(msg, md, json_data, pool, arena, options);
        return AddressBook{
            ._msg = msg,
            ._arena = arena,
        };
    }

    /// Create a new empty message.
    pub fn init(arena: upb_zig.Arena) !AddressBook {
        ensureInit();
        const mt = minitable orelse return error.OutOfMemory;
        const msg = upb_zig.messageNew(mt, arena) orelse return error.OutOfMemory;
        return AddressBook{
            ._msg = msg,
            ._arena = arena,
        };
    }
};
